第二季-专题11-世界一下变大了-MMU 
专题1-世界一下变大了-MMU
历史
许多年以前，当人们还在使用DOS或是更古老的操作系统的时候，计算机的内存还非常小，一般都是以K为单位进行计算，相应的，当时的程序规模也不大，所以内存容量虽然小，但还是可以容纳当时的程序。但随着图形界面的兴起还有用户需求的不断增大，应用程序的规模也随之膨胀起来，终于一个难题出现在程序员的面前，那就是应用程序太大以至于内存容纳不下该程序，通常解决的办法是把程序分割成许多称为覆盖块(overlay)的片段。覆盖块0首先运行，结束时他将调用另一个覆盖块。虽然覆盖块的交换是由OS完成的，但是必须先由程序员把程序先进行分割，这是一个费时费力的工作，而且相当枯燥。人们必须找到更好的办法从根本上解决这个问题。不久人们找到了一个办法，这就是虚拟存储器(virtual memory).虚拟存储器的基本思想是程序，数据，堆栈的总的大小可以超过物理存储器的大小，操作系统把当前使用的部分保留在内存中，而把其他未被使用的部分保存在磁盘上。比如对一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择，可以决定各个时刻将哪4M的内容保留在内存中，并在需要时在内存和磁盘间交换程序片段，这样就可以把这个16M的程序运行在一个只具有4M内存机器上了。而这个16M的程序在运行前不必由程序员进行分割。
相关概念
--地址范围、虚拟地址映射为物理地址 以及 分页机制
任何时候，计算机上都存在一个程序能够产生的地址集合，我们称之为地址范围。这个范围的大小由CPU的位数决定，例如一个32位的CPU，它的地址范围是0~0xFFFFFFFF (4G)，而对于一个64位的CPU，它的地址范围为0~0xFFFFFFFFFFFFFFFF (16E).这个范围就是我们的程序能够产生的地址范围，我们把这个地址范围称为虚拟地址空间，该空间中的某一个地址我们称之为虚拟地址。与虚拟地址空间和虚拟地址相对应的则是物理地址空间和物理地址，大多数时候我们的系统所具备的物理地址空间只是虚拟地址空间的一个子集。这里举一个最简单的例子直观地说明这两者，对于一台内存为256M的32bit x86主机来说，它的虚拟地址空间范围是0~0xFFFFFFFF(4G)，而物理地址空间范围是0x00000000~0x0FFFFFFF(256M)。
在没有使用虚拟存储器的机器上，地址被直接送到内存总线上，使具有相同地址的物理存储器被读写;而在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到存储器管理单元MMU，把虚拟地址映射为物理地址。
大多数使用虚拟存储器的系统都使用一种称为分页(paging)机制。虚拟地址空间划分成称为页(page)的单位，而相应的物理地址空间也被进行划分，单位是页帧(frame).页和页帧的大小必须相同。在这个例子中我们有一台可以生成32位地址的机器，它的虚拟地址范围从0~0xFFFFFFFF(4G)，而这台机器只有256M的物理地址，因此他可以运行4G的程序，但该程序不能一次性调入内存运行。这台机器必须有一个达到可以存放4G程序的外部存储器(例如磁盘或是FLASH)，以保证程序片段在需要时可以被调用。在这个例子中，页的大小为4K，页帧大小与页相同--这点是必须保证的，因为内存和外围存储器之间的传输总是以页为单位的。对应4G的虚拟地址和256M的物理存储器，他们分别包含了1M个页和64K个页帧。
功能
折叠将线性地址映射为物理地址。现代的多用户多进程操作系统，需要MMU，才能达到每个用户进程都拥有自己独立的地址空间的目标。使用MMU,操作系统划分出一段地址区域，在这块地址区域中，每个进程看到的内容都不一定一样。例如MICROSOFT WINDOWS操作系统将地址范围4M-2G划分为用户地址空间，进程A在地址0X400000(4M)映射了可执行文件，进程B同样在地址0X400000(4M)映射了可执行文件，如果A进程读地址0X400000，读到的是A的可执行文件映射到RAM的内容，而进程B读取地址0X400000时，则读到的是B的可执行文件映射到RAM的内容。这就是MMU在当中进行地址转换所起的作用。
折叠提供硬件机制的内存访问授权。多年以来，微处理器一直带有片上存储器管理单元(MMU)，MMU能使单个软件线程工作于硬件保护地址空间。但是在许多商用实时操作系统中，即使系统中含有这些硬件也没采用MMU。
当应用程序的所有线程共享同一存储器空间时，任何一个线程将有意或无意地破坏其它线程的代码、数据或堆栈。异常线程甚至可能破坏内核代码或内部数据结构。例如线程中的指针错误就能轻易使整个系统崩溃，或至少导致系统工作异常。
就安全性和可靠性而言，基于进程的实时操作系统(RTOS)的性能更为优越。为生成具有单独地址空间的进程，RTOS只需要生成一些基于RAM的数据结构并使MMU加强对这些数据结构的保护。基本思路是在每个关联转换中"接入"一组新的逻辑地址。MMU利用当前映射，将在指令调用或数据读写过程中使用的逻辑地址映射为存储器物理地址。MMU还标记对非法逻辑地址进行的访问，这些非法逻辑地址并没有映射到任何物理地址。
这些进程虽然增加了利用查询表访问存储器所固有的系统开销，但其实现的效益很高。在进程边界处，疏忽或错误操作将不会出现，用户接口线程中的缺陷并不会导致其它更关键线程的代码或数据遭到破坏。目前在可靠性和安全性要求很高的复杂嵌入式系统中，仍然存在采无存储器保护的操作系统的情况，这实在有些不可思议。
采用MMU还有利于选择性地将页面映射或解映射到逻辑地址空间。物理存储器页面映射至逻辑空间，以保持当前进程的代码，其余页面则用于数据映射。类似地，物理存储器页面通过映射可保持进程的线程堆栈。RTOS可以在每个线程堆栈解映射之后，很容易地保留逻辑地址所对应的页面内容。这样，如果任何线程分配的堆栈发生溢出，将产生硬件存储器保护故障，内核将挂起该线程，而不使其破坏位于该地址空间中的其它重要存储器区，如另一线程堆栈。这不仅在线程之间，还在同一地址空间之间增加了存储器保护。
存储器保护(包括这类堆栈溢出检测)在应用程序开发中通常非常有效。采用了存储器保护，程序错误将产生异常并能被立即检测，它由源代码进行跟踪。如果没有存储器保护，程序错误将导致一些细微的难以跟踪的故障。实际上，由于在扁平存储器模型中，RAM通常位于物理地址的零页面，因此甚至NULL指针引用的解除都无法检测到。
 
第一课MMU概念解析
嵌入式虚拟地址是32位。
MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器(CPU)中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。
将虚拟地址转化为物理地址
我们才linux程序中访问的地址都是虚拟地址，但是我们最终访问的物理内存，用的是物理地址。这个转化就是用MMU来操作的。MMU就像一个中继站一样，根据不同的进程是有不同的转化过程和不同的映射关系。我们要是没有用MMU，这时的物理地址和虚拟地址就是一样的了。
 
访问权限的管理
MMU在映射的过程中对访问单元是只读的，是不能改变其中内容的。如果变成可写的，就会出现相应的问题。
 
第二课.深入剖析地址转化
 
地址转化总体分析
这里我们需要采用相对应的表格，这个表格是放在内存里。
它的建立是由工程师来完成的。(表格在920T的3-7位置。)
工程师建立完表格，是知道表格的基地址（TTB，translation table bit），再把TTB写到CP15的C2寄存器里面去。这样当MMU工作时，就会从CP15的C2寄存器中取出地址，开始工作。
如果一级页表中最后两位是“10”，接下来的转化过程将按照段方式来进行。
如果一级页表中最后两位是“11”，接下来的转化过程将按照细叶方式来进行。
地址转化类型
（1）段式转化
（2）粗粒度页面转化
（3）细粒度页面转化，linux系统经常使用
 
第三课.MMU的配置与使用
前面的课程我们用的是实际的GPIO地址来完成的，现在我们试图用虚拟的地址来编写。
任务分解
（1）建立一级页表
（2）写入TTB
（3）打开MMU
段映射的原理：
当我们的MMU拿到32位的虚拟地址的时候，首先会把高12地址拿出来，作为一个表的偏移。这张表就是我们的translation table这张表，我们从这张表里面找到一个表项，这个表项里面有个高的12位，这12位指向了我们物理的基地址。我们把物理的基地址拿出来在和我们的32位地址的低地址相拼接。这就得到了我们的虚拟地址对用的实际地址。
一般来说一段的地址是1M。
下面是编写好的程序:
#define CON (volatile unsigned long*)0xA0000060
#define DAT (volatile unsigned long*)0xA0000064
 
/*
 * 用于段描述符的一些宏定义
 */
#define MMU_FULL_ACCESS     (3 << 10)   /* 访问权限 */
#define MMU_DOMAIN          (0 << 5)    /* 属于哪个域 */
#define MMU_SPECIAL         (1 << 4)    /* 必须是1 */
#define MMU_CACHEABLE       (1 << 3)    /* cacheable */
#define MMU_BUFFERABLE      (1 << 2)    /* bufferable */
#define MMU_SECTION         (2)         /* 表示这是段描述符 */左移零位
#define MMU_SECDESC         (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_SECTION)
#define MMU_SECDESC_WB      (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_CACHEABLE | MMU_BUFFERABLE | MMU_SECTION)
void create_page_table(void)
{
    unsigned long *ttb = (unsigned long *)0x20000000;
    unsigned long vaddr, paddr;
    vaddr = 0xA0000000;
    paddr = 0xE0200000;
    *(ttb + (vaddr >> 20)) = (paddr & 0xFFF00000) | MMU_SECDESC;
//建立物理地址和虚拟地址之间的联系
    vaddr = 0x20000000;
    paddr = 0x20000000;
    while (vaddr < 0x24000000)//加到24000000的位置的时候就停止
    {
//物理地址的高12位于0xFFF00000的与
        *(ttb + (vaddr >> 20)) = (paddr & 0xFFF00000) | MMU_SECDESC_WB;
//将物理地址和虚拟地址分别加上1M
        vaddr += 0x100000;
        paddr += 0x100000;
    }
}
void mmu_init()
{
   __asm__(
   
    /*设置TTB*/
    "ldr    r0, =0x20000000\n"                 
    "mcr    p15, 0, r0, c2, c0, 0\n"   
    /*不进行权限检查*/
    "mvn    r0, #0\n"                  
    "mcr    p15, 0, r0, c3, c0, 0\n"   
         /*使能MMU*/
    "mrc    p15, 0, r0, c1, c0, 0\n"   
    "orr    r0, r0, #0x0001\n"         
    "mcr    p15, 0, r0, c1, c0, 0\n"   
    :
    :
  );
}
 
int gboot_main()
{
    create_page_table();
    mmu_init();
    *(CON) = 0x00011000;
    *(DAT) = 0x00000018;
    return 0;   
}
cache的作用
一般程序的存取顺序是，cpu内核——cache——MMU——内存，这样的一个过程。
但是我们有时把一些重要的内容存在cache中，这样在程序运行的时候就会节省运行的时间。一般用C来表示cache。
这里引入另一个概念：write buffer。当我们要往内存中存入一些内容时，有时内容是满的，我们就需要先把我们要存的内容写入write buffer中。当内存空下来的时候，再将内容从write buffer写入内存。用B来表示。表性格式如下：
 
高12位时物理基地址